# Tetris

Implementation of the game "Tetris" in the C programming language using the structural approach.

## Введение

Проект состоят из двух частей: библиотеки, реализующей логику работы игры, которую можно подключать к различным GUI, и терминального интерфейса, разработанного с использованием библиотеки `ncurses`. Логика работы библиотеки реализована с использованием конечных автоматов, одно из возможных описаний которого будет дано ниже.

- Старт — состояние, в котором игра ждет, пока игрок нажмет кнопку готовности к игре.
- Спавн — состояние, в которое переходит игра при создании очередного блока и выбора следующего блока для спавна.
- Перемещение — основное игровое состояние с обработкой ввода от пользователя — поворот блоков/перемещение блоков по горизонтали.
- Сдвиг — состояние, в которое переходит игра после истечения таймера. В нем текущий блок перемещается вниз на один уровень.
- Соединение — состояние, в которое преходит игра после «соприкосновения» текущего блока с уже упавшими или с землей. Если образуются заполненные линии, то она уничтожается и остальные блоки смещаются вниз. Если блок остановился в самом верхнем ряду, то игра переходит в состояние «игра окончена».
- Игра окончена — игра окончена.
![BrickGameConsole](misc/images/brickgame-console.jpg)


Конечный автомат (КА) в теории алгоритмов — математическая абстракция, модель дискретного устройства, имеющего один вход, один выход и в каждый момент времени находящегося в одном состоянии из множества возможных.

При работе на вход КА последовательно поступают входные воздействия, а на выходе КА формирует выходные сигналы. Переход из одного внутреннего состояния КА в другое может происходить не только от внешнего воздействия, но и самопроизвольно.

КА можно использовать для описания алгоритмов, позволяющих решать те или иные задачи, а также для моделирования практически любого процесса. Несколько примеров:

- Логика искусственного интеллекта для игр;
- Синтаксический и лексический анализ;
- Сложные прикладные сетевые протоколы;
- Потоковая обработка данных.  

Ниже представлены примеры использования КА для формализации игровой логики нескольких игр из BrickGame.

### Фроггер

![Фроггер](misc/images/frogger-game.png)

«Фроггер» — одна из поздних игр, выходящих на консолях Brickgame. Игра представляет собой игровое поле, по которому движутся бревна, и, перепрыгивая по ним, игроку необходимо перевести лягушку с одного берега на другой. Если игрок попадает в воду или лягушка уходит за пределы игрового поля, то лягушка погибает. Игра завершается, когда игрок доводит лягушку до другого берега или погибает последняя лягушка.

Для формализации логики данной игры можно представить следующий вариант конечного автомата:

![Конечный автомат фроггера](misc/images/frogger.jpg)

Данный КА имеет следующие состояния:

- Старт — состояние, в котором игра ждет, пока игрок нажмет кнопку готовности к игре.
- Спавн — состояние, в котором создается очередная лягушка.
- Перемещение — основное игровое состояние с обработкой ввода от пользователя — движение лягушки по полосе влево/право или прыжки вперед/назад.
- Сдвиг — состояние, которое наступает после истечения таймера, при котором сдвигаются все объекты на полосах вправо, вместе с лягушкой.
- Столкновение — состояние, которое наступает, если после прыжка лягушка попадает в воду или после смещения бревен лягушка оказывается за пределами игрового поля.
- Достигнут другой берег — состояние, которое наступает при достижении лягушкой верхней другого берега.
- Игра окончена — состояние, которое наступает после достижения другого берега или смерти последней лягушки.

Пример реализации фроггера с использованием КА вы можете найти в папке `code-samples`.

### Тетрис

![Тетрис](misc/images/tetris-game.png)

«Тетрис», наверное, одна из самых популярных игр для консоли Brickgame. Нередко и саму консоль называют тетрисом. Цель игры — в наборе очков за построение линий из генерируемых игрой блоков. Очередной блок, сгенерированный игрой, начинает опускаться вниз по игровому полю, пока не достигнет нижней границы или не столкнется с другим блоком. Пользовать может поворачивать фигуры и перемещать их по горизонтали, стараясь составлять ряды. После заполнения ряд уничтожается, игрок получает очки, а блоки, находящиеся выше заполненного ряда опускаются вниз. Игра заканчивается, когда очередная фигура останавливается в самом верхнем ряду.

Для формализации логики данной игры можно представить следующий вариант конечного автомата:

![Конечный автомат тетриса](misc/images/tetris.png)

Данный КА состоит из следующих состояний:

- Старт — состояние, в котором игра ждет, пока игрок нажмет кнопку готовности к игре.
- Спавн — состояние, в которое переходит игра при создании очередного блока и выбора следующего блока для спавна.
- Перемещение — основное игровое состояние с обработкой ввода от пользователя — поворот блоков/перемещение блоков по горизонтали.
- Сдвиг — состояние, в которое переходит игра после истечения таймера. В нем текущий блок перемещается вниз на один уровень.
- Соединение — состояние, в которое преходит игра после «соприкосновения» текущего блока с уже упавшими или с землей. Если образуются заполненные линии, то она уничтожается и остальные блоки смещаются вниз. Если блок остановился в самом верхнем ряду, то игра переходит в состояние «игра окончена».
- Игра окончена — игра окончена.

## Chapter II <div id="chapter-ii"></div>
## Требования к проекту

### Часть 1. Основное задание


- Программа разработана на языке Си стандарта C11 с использованием компилятора gcc.
- Программа состоят из двух частей: библиотеки, реализующей логику игры тетрис, и терминального интерфейса с использованием библиотеки `ncurses`.
- Для формализации логики игры использован конечный автомат.
- Код библиотеки программы находится в папке `src/brick_game/tetris`.
- Код с интерфейсом программы находится в папке `src/gui/cli`.
- Сборка программы настроена с помощью Makefile со стандартным набором целей для GNU-программ: all, install, uninstall, clean, dvi, dist, test, gcov_report. Установка ведется в каталог bin корневого каталога.
- Программа разработана в соответствии с принципами структурного программирования.
- Код соответствует Google Style.
- Обеспечено покрытие библиотеки unit-тестами, с помощью библиотеки `check` 
- В игре присутствуют следующие механики:
  - Вращение фигур;
  - Перемещение фигуры по горизонтали;
  - Ускорение падения фигуры (при нажатии кнопки фигура перемещается до конца вниз);
  - Показ следующей фигуры;
  - Уничтожение заполненных линий;
  - Завершение игры при достижении верхней границы игрового поля;
- Для управления предусмотрены кнопки:
  - Начало игры,
  - Пауза,
  - Завершение игры,
  - Стрелка влево — движение фигуры влево,
  - Стрелка вправо — движение фигуры вправо,
  - Стрелка вниз — падение фигуры,
  - Стрелка вверх — ни используется в данной игре,
  - Действие (вращение фигуры).
- Игровое поле имеет размеры десять «пикселей» в ширину и двадцать «пикселей» в высоту.
- Фигура, после достижения нижней границы поля или соприкосновения с другой фигурой останавливается. После этого происходит генерация следующей фигуры, показанной на превью.
- Пользовательский интерфейс поддерживает отрисовку игрового поля и дополнительной информации.

Используемые фигуры:

![Фигуры](misc/images/tetris-pieces.png)

### Часть 2. Дополнительно. Подсчет очков и рекорд в игре

Добавь в игру следующие механики:

- подсчет очков;
- хранение максимального количества очков.

Данная информация должна передаваться и выводиться пользовательским интерфейсом в боковой панели. Максимальное количество очков должно храниться в файле или встраиваемой СУБД и сохраняться между запусками программы.

Максимальное количество очков должно изменяться во время игры, если пользователь во время игры превышает текущий показатель максимального количества набранных очков.

Начисление очков будет происходить следующим образом:

- 1 линия — 100 очков;
- 2 линии — 300 очков;
- 3 линии — 700 очков;
- 4 линии — 1500 очков.

### Часть 3. Дополнительно. Механика уровней

Добавь в игру механику уровней. Каждый раз, когда игрок набирает 600 очков, уровень увеличивается на 1. Повышение уровня увеличивает скорость движения фигур. Максимальное количество уровней — 10.

💡 [Нажми сюда](https://forms.yandex.ru/cloud/65d4a02673cee73bdc52da80/)**, чтобы поделиться с нами обратной связью на этот проект**. Это анонимно и поможет нашей команде сделать твоё обучение лучше.
